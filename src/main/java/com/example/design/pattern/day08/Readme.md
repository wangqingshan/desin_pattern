**原型模式**

-
原型模式虽然是创建型模式，但是与工程模式没有关系，从名字即可看出，该模式的思想就是将对象作为一个
原型，对其进行复制、克隆，产生一个和原对象类似的新对象。

在java中，复制对象是通过clone()实现的。


理解深度克隆与浅度克隆

浅度克隆：对某个对象克隆，对应的成员变量如果包括引用类型和数组，那么克隆的时候是不会把这些对象也
带着复制到克隆出来的对象里面的，只是复制了一个引用，这个引用指向被克隆对象的成员对象，但是基本数据
类型是会跟着被带到克隆对象里面去的。

深度克隆：就是把对象所有的属性都统统复制一份新的到目标对象里面去。

-
原型模式主要包含如下三个角色：

Prototype:抽象原型类。声明克隆自身的接口。

ConcretePrototype:具体原型类。实现克隆的具体操作。

Client:客户类。让一个原型克隆自身，从而获得一个新的对象。


-

我们都知道Object是祖宗，所有的java类都继承至Object,而Object类提供了一个
clone方法，该方法可以将java对象复制一份，因此在java中可以直接使用clone方法
来复制一个对象。但是需要实现clone的java类必须要实现一个接口：Cloneale。该
接口表示该类能够复制且具体复制的能力，如果不实现该接口而直接调用clone方法
会抛出CloneNotSupportedException异常。

-
优点：

1.如果创建新的对象比较复杂的时候，可以利用原型模式简化对象的创建过程，同时提高
效率

2.可以使用深度克隆保持对象的状态。

3.原型模式提供了简化的创建结构。

缺点：

1.在实现深度克隆的时候可能需要比较复杂的代码

2.需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行全盘考虑。
这对新的类来说不难，但对已有的类进行改造时，不一定是件容易的事，必须修改
源码，违背了“开闭原则”

模式的使用场景：

1.如果创建的对象成本较大，我们可以利用已有的对象进行复制来获得。

2.如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大
的时候，也可以使用原型模式配合备忘录模式来使用，相反如果对象变化很大，或者
对象占用内存很大，那么采用状态模式比原型模式要好。

3.需要避免分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或者很少
的几个组合状态，通过复制原型对象得到新的实例可能比使用构造函数创建一个新的实例更方便。


总结：

1.原型模式向客户隐藏了创建对象的复杂性。客户只需要要创建对象的类型，然后通过
请求就可以获得和该对象一模一样的新对象。无需知道具体的流程。

2.克隆分为浅克隆和深克隆。

3.我们可以利用原型模式来获得一个新对象，但有时对象的复制可能相当复杂。比如深度克隆。

-
序列化：

序列化就是将对象写到流的一个过程，写到流里面去（就是字节流）就等于复制了对象，但是
原来的对象并没有动，只是复制将类型通过流的方式去读取，然后写到另一个内存地址中去。















